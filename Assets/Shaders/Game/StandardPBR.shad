// Reference: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
#version 450
#include "Common/Common.glsl"
#include "VirtualTexture/VirtualTexture.glsl"
#define M_PI 3.1415926535897932384626433832795

#if CONFIG
name: Game/StandardPBR
#endif

#if VERT
layout(location = 0) in vec3 i_Position;
layout(location = 1) in vec3 i_Normal;
layout(location = 2) in vec3 i_Tangent;
layout(location = 3) in vec2 i_UV;

layout(location = 0) out vec3 o_PositionWS;
layout(location = 1) out vec3 o_NormalWS;
layout(location = 2) out vec3 o_TangentWS;
layout(location = 3) out vec3 o_BinormalWS;
layout(location = 4) out vec2 o_UV;
void main()
{
    o_PositionWS = vec3(pconst.model * vec4(i_Position, 1));
    o_NormalWS = (inverse(transpose(pconst.model)) * vec4(i_Normal,1)).xyz;
    o_TangentWS = (inverse(transpose(pconst.model)) * vec4(i_Tangent,1)).xyz;
    o_BinormalWS = cross(o_NormalWS, o_TangentWS);
    o_UV = i_UV;

    gl_Position = scene.viewProjection * vec4(o_PositionWS, 1);
}
#endif

#if FRAG
layout(location = 0) in vec3 i_PositionWS;
layout(location = 1) in vec3 i_NormalWS;
layout(location = 2) in vec3 i_TangentWS;
layout(location = 3) in vec3 i_BinormalWS;
layout(location = 4) in vec2 i_UV;

layout(location = 0) out vec4 o_Color;

layout(set = SET_MATERIAL, binding = 0) uniform PBR
{
    float roughness;
    float metallic;
} matParams;

#define AlbedoMap albedoMap_sampler_linear
#define NormalMap normalMap_sampler_linear

layout(set = SET_MATERIAL, binding = 1) uniform sampler2D AlbedoMap;
layout(set = SET_MATERIAL, binding = 2) uniform sampler2D roughnessMap;
layout(set = SET_MATERIAL, binding = 3) uniform sampler2D metallicMap;
layout(set = SET_MATERIAL, binding = 4) uniform sampler2D NormalMap;

#define Roughness matParams.roughness
#define Metallic matParams.metallic
#define NearZero 0.000001

float pow2(float x)
{
    return x * x;
}

void main()
{
// get normal
    vec3 tangent = normalize(i_TangentWS);
    vec3 normal = normalize(i_NormalWS);
    vec3 binormal = normalize(i_BinormalWS);
    mat3 TBN = {tangent, binormal, normal};
    vec3 normalMap = texture(NormalMap, i_UV).xyz;
    normal = TBN * normalMap;

    float roughness = Roughness * texture(roughnessMap, i_UV).r;
    float metallic = Metallic * texture(metallicMap, i_UV).r;
    vec3 finalColor = vec3(0,0,0);

    for (int i = 0; i < scene.lightCount; ++i)
    {
        vec4 lightPos = scene.lights[i].position;
        vec3 v = normalize(scene.viewPos - i_PositionWS);
        vec3 l = lightPos.xyz;
        vec3 n = normalize(normal);

        vec3 h = normalize(l + v);
        float dotNH = max(dot(n,h), NearZero);
        float dotNV = max(dot(n,v), NearZero);
        float dotNL = max(dot(n,l), NearZero);
        float dotVH = max(dot(v,h), NearZero);
        float r2 = roughness * roughness;

    // ndf
        float D = r2 / (M_PI * pow2(pow2(dotNH) * (r2 - 1) + 1));

    // geometry
        float k = pow2(roughness + 1) / 8;
        float Gv = dotNV / (dotNV * (1 - k) + k);
        float Gl = dotNL / (dotNL * (1 - k) + k);
        float G = Gv * Gl;

    // fresnel
        float F = metallic + (1 - metallic) * pow(2, (-5.55472 * dotVH - 6.98316) * dotVH);

        float brdf = (G * F * D) / (4 * dotNL * dotNV);
        float light = dotNL * scene.lights[i].intensity;
        vec3 albedo = texture(AlbedoMap, i_UV).xyz / M_PI;
        finalColor += (0.1 + light) * (albedo + brdf);
    }

    o_Color = vec4(finalColor, 1);
}
#endif


